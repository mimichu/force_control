// LodaCell.h : handle communication with Phidget lc_bridge module, use load cell

#ifndef _EGM_CLASS_HEADER_
#define _EGM_CLASS_HEADER_

#include <pthread.h>

#include <matvec/matvec.h>

#include "PracticalSocket.h" // For UDPSocket and SocketException
#include "TimerLinux.h"
#include "egm.pb.h" // generated by Google protoc.exe

using namespace abb::egm;

/// Controller Mode. Determines how the Monitor() function behaves.
/// CT_MODE_POSITION: position control mode. SetPose() is available.
/// CT_MODE_VELOCITY: velocity control mode. SetSpeed() is available.
/// CT_MODE_TRANSPARENT: no thread. use listen() and send() to directly
/// communicate with egm.
typedef enum
{
	CT_MODE_POSITION,
	CT_MODE_VELOCITY,
	CT_MODE_TRANSPARENT
} ControlMode;

#define EGM_PERIOD 4.0 // 4ms


class EGMClass
{
public:
	/// for singleton implementation 
	static EGMClass* Instance();

	// ----------------------------------------
	// 	user interfaces
	// ----------------------------------------

	/// Establish communication with abb egm, create thread to run communication with EGM
	/// \param portnum the port number 
	/// \param speed_limit_tran speed limit for translation, mm/s 
	/// \param speed_limit_rot speed limit for rotation, degree/s
	int  initialization(unsigned short portnum, float speed_limit_tran, float speed_limit_rot, ControlMode mode);
	///  Interface for reading robot pose. The pose is updated every 4ms. 
	/// Must be called after initialization.
	/// \param pose a pointer to a dim=7 array. 
	int GetCartesian(float *pose);
	/// In position control mode, set the desired robot cartesian pose.
	/// \param pose dim = 7.
	int SetCartesian(float *pose);
	/// The velocity used in position control mode.
	int SetCartesianVel(float vel_tran, float vel_rot);
	/// In velocity control mode, set the desired robot speed.
	/// \param v dim=3, 3-axis velocity, mm/s
	/// \param w dim=3, 3-axis angular velocity, rad/s
	int SetVelocity(float *v, float *w);
	/// Wait until obtaining a message from egm. Then read it using ReadRobotMessage().
	/// \sa ReadRobotMessage()
	int listen();
	/// Send a message to egm. The command will be checked by _vel_limit_tran 
	/// and _vel_limit_rot
	void send(float* pose);

	// ----------------------------------------
	// 	state and parameters
	// ----------------------------------------
	
	bool _isInitialized; ///< indicates whether the initialization() function is called.
	ControlMode _mode; ///< controller mode
	float _vel_limit_tran; ///< (mm/s)
							 ///< \sa initialization()
	float _vel_limit_rot; ///<  (rad/s)
							 ///< \sa initialization()
	float _vel_tran; ///< (mm/s)
	float _vel_rot;  ///< (rad/s)

	float *_set_pose; ///< goal robot pose. dim = 7
	float *_set_vel; ///< goal velocity. dim = 6

	// MISC
	Timer _timer; ///< high resolution timer.
 
private: 
	/// for singleton implementation 
	static EGMClass* pinstance; 
	/// for singleton implementation 
	EGMClass(); 
	/// for singleton implementation 
	EGMClass(const EGMClass&); 
	/// for singleton implementation 
	EGMClass& operator= (const EGMClass&); 
	~EGMClass(); 


	/// Create a message based on egm message proto.
	int CreateSensorMessage(EgmSensor* pSensorMessage, float *pose);
	/// Create an empty message based
	void CreateSensorMessageEmpty(EgmSensor* pSensorMessage);
	/// Read the current pose from a robot message.
	void ReadRobotMessage(EgmRobot *pRobotMessage);
	/// Display the info contained in a robot message.
	void DisplayRobotMessage(EgmRobot *pRobotMessage);

	// robot state
	float *_pose; ///< robot pose. dim = 7

	// thread
	pthread_t _thread;


	// socket connection
	UDPSocket _EGMsock;
    string _sendBuffer;
    string _RobotAddress;  
    unsigned short _RobotPort;

	// Egm message
    EgmSensor *_pSendingMessage;
    EgmRobot *_pRecvMessage;
};

#endif