//List of header files
//System
#include <iostream>
#include <stdio.h>
#include <dlfcn.h>
#include <unistd.h>
#include <ctime>
#include <math.h>
#include <pthread.h>
#include <fstream>
#include <string>
#include <memory>
#include <cstdlib>
#include <time.h>
#include <iomanip>
#include <sys/time.h>
#include <sys/resource.h>
#include <typeinfo>
//ABB Robot
#include "PracticalSocket/PracticalSocket.h" // For UDPSocket and SocketException
#include "egm.pb.h" // generated by Google protoc.exe

using namespace abb::egm;

// *********************************
// Create a simple robot message
void CreateSensorMessage(EgmSensor* pSensorMessage, float x, float y)
{
    static unsigned int sequenceNumber = 0;
    EgmHeader* header = new EgmHeader();
    header->set_mtype(EgmHeader_MessageType_MSGTYPE_CORRECTION);
    header->set_seqno(sequenceNumber++);
    header->set_tm(0);
    // header->set_tm(GetTickCount());

    pSensorMessage->set_allocated_header(header);

    EgmCartesian *pc = new EgmCartesian();
    //float z = 0.221;  //pu
    float z = 0.230;  //plywood
    if(x > 0.55) x = 0.55;
    if(x < 0.10) x = 0.10;
    if(y > 0.2) y = 0.2;
    if(y < -0.2) y = -0.2;
    pc->set_x(x*1000);    // convert to robot representation mm
    pc->set_y(y*1000);
    pc->set_z(z*1000);
    EgmQuaternion *pq = new EgmQuaternion();
    pq->set_u0(0);   // need to fill in
    pq->set_u1(0);
    pq->set_u2(1);
    pq->set_u3(0);

    EgmPose *pcartesian = new EgmPose();
    pcartesian->set_allocated_orient(pq);
    pcartesian->set_allocated_pos(pc);

    EgmPlanned *planned = new EgmPlanned();
    planned->set_allocated_cartesian(pcartesian);

    pSensorMessage->set_allocated_planned(planned);
}
// ***********************************
void CreateSensorMessageEmpty(EgmSensor* pSensorMessage)
{
    static unsigned int sequenceNumber = 0;
    EgmHeader* header = new EgmHeader();
    header->set_mtype(EgmHeader_MessageType_MSGTYPE_CORRECTION);
    header->set_seqno(sequenceNumber++);
    header->set_tm(0);
    // header->set_tm(GetTickCount());

    pSensorMessage->set_allocated_header(header);

}

// ************************
void DisplayRobotMessage(EgmRobot *pRobotMessage, double& x, double& y, double& z)
{
    double x_robot, y_robot, z_robot;
    if (pRobotMessage->has_header() && pRobotMessage->header().has_seqno() && pRobotMessage->header().has_tm() && pRobotMessage->header().has_mtype()  )
    {
        //printf("SeqNo=%d Tm=%u Type=%d\n", pRobotMessage->header().seqno(), pRobotMessage->header().tm(), pRobotMessage->header().mtype());
    x_robot =  pRobotMessage->feedback().cartesian().pos().x();
    y_robot =  pRobotMessage->feedback().cartesian().pos().y();
    z_robot =  pRobotMessage->feedback().cartesian().pos().z();

    x = x_robot / 1000;
    y = y_robot / 1000;
    z = z_robot /1000;
    }
    else
    {
        printf("No header\n");
    }
}

void DisplayRobotMessage(EgmRobot *pRobotMessage)
{
    if (pRobotMessage->has_header() && pRobotMessage->header().has_seqno() && pRobotMessage->header().has_tm() && pRobotMessage->header().has_mtype())
    {
        printf("SeqNo=%d Tm=%u Type=%d\n", pRobotMessage->header().seqno(), pRobotMessage->header().tm(), pRobotMessage->header().mtype());
    }
    else
    {
        printf("No header\n");
    }
}


//Define shortcuts
using namespace std;

//*********************** Main Program *************************************
int main(int argc,  char *argv[]){
    
    // -------------------------------------------------------
    //  Create socket and wait for robot's connection
    // -------------------------------------------------------

    // open an UDP port on this server, listening
    const int portNumber = 6510;   // port number of this server 
    UDPSocket EGMsock(portNumber);
    printf("Listening:\n");

    // address of the Robot (EGM)
    // will be filled up upon receiving
    string RobotAddress;  
    unsigned short RobotPort = 0;


    // buffers
    #define RCBFLENGTH 1400
    EgmSensor *pSendingMessage = new EgmSensor();
    EgmRobot *pRecvMessage = new EgmRobot();
    double tmp = 0;
    char recvBuffer[RCBFLENGTH];
    string sendBuffer;

    // printf("EGM server is Running..\n");
    // for (int i =0;i<150000;i++)
    // {
    //     printf("Waiting to receive...\n");
    //     EGMsock->recvFrom(receivingBuffer.c_str(), receivingBuffer.length(), RobotAddress, RobotPort);

    //     //Get time---------------------------------------------------------------------------------------------------------------------
    //     // if (i==0){t_ini = gettime();}
    //     // time = gettime()- t_ini;
    //     printf("\r runing at timestep %d", i );
    //     // Send commands of end effector position x_tcp, y_tcp
    //     CreateSensorMessage(pSendingMessage, 0, 0);
    //     pSendingMessage->SerializeToString(&sendBuffer);
    //     EGMsock->sendTo(sendBuffer.c_str(), sendBuffer.length(), RobotAddress, RobotPort);
    // }


    for (int messages = 0; messages < 100; messages++)
    {
        printf("Waiting to receive...\n");

        // receive and display message from robot
        int n = EGMsock.recvFrom(recvBuffer, RCBFLENGTH, RobotAddress, RobotPort);
        if (n < 0)
        {
            printf("Error receive message\n");
            continue;
        }

        printf("[Egm server node] message received!\n");
        printf("Address: %s, port: %d\n",RobotAddress.c_str(),RobotPort);
        getchar();
        
        // deserialize inbound message
        EgmRobot *pRecvMessage = new EgmRobot();
        pRecvMessage->ParseFromArray(recvBuffer, n);
        DisplayRobotMessage(pRecvMessage);
        delete pRecvMessage;


        // create and send a sensor message
        EgmSensor *pSendingMessage = new EgmSensor();
        CreateSensorMessage(pSendingMessage, 0, 0);
        pSendingMessage->SerializeToString(&sendBuffer);

        // send a message to the robot
        EGMsock.sendTo(sendBuffer.c_str(), sendBuffer.length(), RobotAddress, RobotPort);
        // n = sendto(sockfd, sendBuffer.c_str(), sendBuffer.length(), 0, (struct sockaddr *)&clientAddr, sizeof(clientAddr));
        // if (n < 0)
        // {
        //     printf("Error send message\n");
        // }
        delete pSendingMessage;
    }
    return 0;
}
